TALLOC2(3)
=========


NAME
----
talloc2 - Hierarchical memory allocator with some extensions.



SYNOPSIS
--------
*#include <talloc2/types.h>*

    typedef void talloc_context;
    typedef uint8_t ( * talloc_destructor_function ) ( talloc_context * chunk_context, void * user_data );
    
*#include <talloc2/tree.h>*

    talloc_context * talloc         ( const talloc_context * parent_context, size_t length );
    talloc_context * talloc_zero    ( const talloc_context * parent_context, size_t length );
    talloc_context * talloc_new     ( const talloc_context * parent_context );
    talloc_context * talloc_realloc ( const talloc_context * chunk_context, size_t length );
    uint8_t          talloc_move    ( const talloc_context * child_context, const talloc_context * parent_context );
    uint8_t          talloc_free    ( const talloc_context * chunk_context );
    
*#include <talloc2/helpers.h>*

    char * talloc_strndup ( const talloc_context * parent_context, const char * str, size_t length );
    char * talloc_strdup  ( const talloc_context * parent_context, const char * str );

*#include <talloc2/events.h>*

    size_t talloc_get_chunks_count           ();
    size_t talloc_get_chunks_overhead_length ();
    size_t talloc_get_chunks_length          ();

*#include <talloc2/extensions/destructor.h>*

    uint8_t talloc_clear_destructors          ( const talloc_context * chunk_context );
    uint8_t talloc_add_destructor             ( const talloc_context * chunk_context, talloc_destructor_function function, void * user_data );
    uint8_t talloc_del_destructor             ( const talloc_context * chunk_context, talloc_destructor_function function, void * user_data );
    uint8_t talloc_del_destructor_by_function ( const talloc_context * chunk_context, talloc_destructor_function function );
    uint8_t talloc_del_destructor_by_data     ( const talloc_context * chunk_context, void * user_data );
    
*#include <talloc2/reference/main.h>*

    talloc_context * talloc_add_reference                ( const talloc_context * child_context, const talloc_context * parent_context );
    talloc_context * talloc_add_reference_with_data      ( const talloc_context * child_context, const talloc_context * parent_context, size_t length );
    talloc_context * talloc_add_reference_with_zero_data ( const talloc_context * child_context, const talloc_context * parent_context, size_t length );
    uint8_t          talloc_clear_references             ( const talloc_context * chunk_context );
    
*#include <talloc2/utils/dynarr.h>*

    talloc_dynarr * talloc_dynarr_new           ( const talloc_context * ctx, size_t capacity );
    uint8_t         talloc_dynarr_insert_before ( talloc_dynarr * arr, size_t index, void * data );
    uint8_t         talloc_dynarr_insert_after  ( talloc_dynarr * arr, size_t index, void * data );
    uint8_t         talloc_dynarr_grow_and_set  ( talloc_dynarr * arr, size_t index, void * data );
    void            talloc_dynarr_set           ( talloc_dynarr * arr, size_t index, void * data );
    void *          talloc_dynarr_get           ( const talloc_dynarr * arr, size_t index );
    size_t          talloc_dynarr_get_length    ( const talloc_dynarr * arr );
    uint8_t         talloc_dynarr_push          ( talloc_dynarr * arr, void * data );
    uint8_t         talloc_dynarr_pop           ( talloc_dynarr * arr );
    uint8_t         talloc_dynarr_delete        ( talloc_dynarr * arr, size_t index );
    
*#include <talloc2/utils/buffer.h>*

    talloc_buffer * talloc_buffer_new             ( const talloc_context * ctx );
    void            talloc_buffer_written         ( talloc_buffer * buffer, size_t length );
    uint8_t         talloc_buffer_readed          ( talloc_buffer * buffer, size_t length );
    uint8_t *       talloc_buffer_get_read_point  ( const talloc_buffer * buffer );
    uint8_t *       talloc_buffer_get_write_point ( const talloc_buffer * buffer );
    size_t          talloc_buffer_get_length      ( const talloc_buffer * buffer );
    uint8_t         talloc_buffer_prepare         ( talloc_buffer * buffer, size_t length );
    uint8_t         talloc_buffer_trim            ( talloc_buffer * buffer );



DESCRIPTION
-----------
Talloc2 is a hierarchical memory allocator with some extensions.
It is an alternative implementation of simplified talloc api.
The main goal of the project is to minimize memory overhead.
Size of usual chunk is 32-49 bytes, size of reference chunk is 57-65 bytes on 64 bit system (depends on compiled features).
Debug features will increase size of each chunk by 16 bytes.

Implementation uses tree to store chunks, not graph. All important functions have O(1) complexity.
Each chunk has one parent chunk, prev chunk, next chunk and child chunks list.

You can store data after each chunk.
There is a data before each chunk : extensions or reference.
Extensions store destructors and references lists.
References store destructors, prev reference, next reference and related extensions.

You can create, move, realloc and free any chunk.
You can add reference chunk to any chunk. ( reference will be added to it's extensions. if you are adding reference to reference it will add reference to related extensions. )
You can add destructors to any chunk.

Deletion of chunk works as follows.
If chunk is usual and it's references list is not empty - it with it's subtree will become root independent tree and delete operation will not proceed to it's children.
Otherwise it will be deleted.
If chunk is reference it will be deleted.
If related chunk is a root of independent tree and it's references list is empty - it will be deleted.
All chunk's destructors will be invoked on delete.



WARNING
-------
Do not use talloc on non-talloc pointers.
You will obtain unexpected behaviour.

    char * a = malloc ( sizeof ( char ) * 5 );
    talloc_add_destructor ( a, destructor_function, NULL ); // unexpected behaviour

Do not move reference to the subtree of it's related chunk.
You can obtain a memory leak.

    int * a     = talloc ( NULL, sizeof( int ) );
    int * b     = talloc ( a,    sizeof( int ) );
    int * b_ref = talloc_add_reference ( b, a );
    // talloc_free ( a ); can't delete a, because it has references
    talloc_free ( b_ref ); talloc_free ( a );



types.h
-------
*typedef void talloc_context;*

You can use talloc_context * to sign, that this pointer can be provided to talloc functions.

*typedef uint8_t ( * talloc_destructor_function ) ( talloc_context * chunk_context, void * user_data );*

You can provide such function as a destructor. See talloc_add_destructor for more information.



tree.h
------
*talloc_context * talloc ( const talloc_context * parent_context, size_t length );*

Function uses malloc to allocate new chunk with size = sizeof ( chunk ) + length.
If parent_context is NULL function will set new chunk as root independent chunk.
Otherwise it will obtain parent chunk from parent_context and attach new chunk to parent chunk.
parent_context can be both usual and reference.
Function returns pointer to memory (with length size) or NULL if error occurred.
Complexity is complexity of malloc + O(1).

*talloc_context * talloc_zero ( const talloc_context * parent_context, size_t length );*

Function works the same as "talloc".
It will use calloc instead of malloc to allocate new chunk.
Complexity is complexity of calloc + O(1).

*talloc_context * talloc_new ( const talloc_context * parent_context );*

Function uses malloc to allocate new chunk with size = sizeof ( chunk ).
If parent_context is NULL function will set new chunk as root independent chunk.
Otherwise it will obtain parent chunk from parent_context and attach new chunk to parent chunk.
parent_context can be both usual and reference.
Function returns pointer to memory (with zero size) or NULL if error occurred.
This memory should not be used for storing information.
Complexity is complexity of malloc + O(1).

*uint8_t talloc_free ( const talloc_context * chunk_context );*

Function obtains chunk from chunk_context, detaches it from the tree and start delete operation on subtree starting from it.
chunk_context can be both usual and reference.
If chunk is usual and it has reference(s) - it will become root independent chunk and delete operation will not go to it's children.
Otherwise it will be deleted. All it's destructors will be invoked.
If chunk is reference it will be deleted. All it's destructors will be invoked.
If linked usual chunk is root independent chunk and it has no references - it will be deleted. All it's destructors will be invoked.
Function returns zero if delete operations were successful and non-zero value otherwise.
Non-zero value meaning is "error code of the last failed operation". Function will not stop on errors.
Complexity is complexity of free * number of deleted chunks + O(number of deleted chunks).

*talloc_context * talloc_realloc ( const talloc_context * chunk_context, size_t length );*

Function obtains chunk from chunk_context, uses realloc to change size of chunk from current_length to length.
chunk_context can be both usual and reference.
Function returns pointer to memory (with length size) or NULL if error occurred.
If realloc changes memory pointer complexity will be complexity of realloc + O(number of linked chunks) + O(number of linked references);
Otherwise complexity is complexity of realloc + O(1).

*uint8_t talloc_move ( const talloc_context * child_context, const talloc_context * parent_context );*

Function obtains child chunk from child_context, parent chunk from parent_context.
chunk_context and parent_context can be both usual and reference.
Function detaches child chunk from it's parent and attaches it to new parent chunk.
Function returns zero if move operation was successful and non-zero value otherwise.
Complexity is O(1).

*Example*

    int main ()
    {
        talloc_context * root = talloc_new ( NULL );
        if ( root == NULL ) {
            return 1;
        }
        int16_t * numbers = talloc_zero ( root, sizeof ( int16_t ) * 5 );
        char * string     = talloc      ( root, sizeof ( char ) * 10 );
        if ( numbers == NULL || string == NULL ) {
            talloc_free ( root );
            return 2;
        }
        if ( talloc_move ( string, numbers ) != 0 ) {
            talloc_free ( root );
            return 3;
        }
        numbers = talloc_realloc ( numbers, sizeof ( int16_t ) * 3 );
        string  = talloc_realloc ( string,  sizeof ( char ) * 20 );
        if ( numbers == NULL || string == NULL ) {
            talloc_free ( root );
            return 4;
        }
        if ( talloc_free ( root ) != 0 ) {
            return 5;
        }
        return 0;
    }



helpers.h
---------
*char * talloc_strndup ( const talloc_context * parent_context, const char * str, size_t length );*

Function makes duplicate from length bytes of str.
If parent_context is NULL function will set new chunk as root independent chunk.
Otherwise it will obtain parent chunk from parent_context and attach new chunk to parent chunk.
Function returns pointer to memory (with length + 1 size) or NULL if error occurred.
Complexity is complexity of talloc + complexity of memmove + O(1).

*char * talloc_strdup ( const talloc_context * parent_context, const char * str );*

Function makes duplicate of str.
If parent_context is NULL function will set new chunk as root independent chunk.
Otherwise it will obtain parent chunk from parent_context and attach new chunk to parent chunk.
Function returns pointer to memory (with strlen ( str ) + 1 size) or NULL if error occurred.
Complexity is complexity of talloc_strndup.

*Example*

    int main ()
    {
        talloc_context * root = talloc_new ( NULL );
        if ( root == NULL ) {
            return 1;
        }
        char * string = talloc_strdup ( root, "Some test text." );
        if ( string == NULL ) {
            talloc_free ( root );
            return 2;
        }
        char * text = talloc_strndup ( string, string + 10, 4 );
        if ( text == NULL || strcmp ( text, "text" ) != 0 ) {
            talloc_free ( root );
            return 3;
        }
        if ( talloc_free ( root ) != 0 ) {
            return 4;
        }
        return 0;
    }



talloc2/events.h
----------------
*size_t talloc_get_chunks_count ();*

Function returns global count of chunks.

*size_t talloc_get_chunks_overhead_length ();*

Function returns global length used by chunk's controll structures.

*size_t talloc_get_chunks_length ();*

Function returns global usable for user length of chunks.

*Example*

    int main ()
    {
        ...
        
        #if defined(TALLOC_DEBUG)
        if (
            talloc_get_chunks_count()           != 0 ||
            talloc_get_chunks_overhead_length() != 0 ||
            talloc_get_chunks_length()          != 0
            ) {
            return 1;
        }
        #endif
        
        return 0;
    }



extensions/destructor.h
-----------------------
*uint8_t talloc_clear_destructors ( const talloc_context * chunk_context );*

If chunk_context is NULL function will return non-zero value.
Otherwise function will obtain chunk from chunk_context and clear it's destructors list.
Destructors will not be called.
Function returns zero or non-zero value if error occurred.
Complexity is complexity of free * number of destructors + O(number of destructors).

*uint8_t talloc_add_destructor ( const talloc_context * chunk_context, talloc_destructor_function function, void * user_data );*

If chunk_context is NULL function will return non-zero value.
Otherwise function will obtain chunk from chunk_context, create destructor from function + user_data and add it to chunk's destructors list.
Function returns zero or non-zero value if error occurred.
Complexity is complexity of malloc + O(1).

*uint8_t talloc_del_destructor ( const talloc_context * chunk_context, talloc_destructor_function function, void * user_data );*

If chunk_context is NULL function will return non-zero value.
Otherwise function will obtain chunk from chunk_context and delete destructor by function + user_data from it's destructors list.
Function returns zero or non-zero value if error occurred.
Complexity is complexity of free + O(number of linked destructors).

*uint8_t talloc_del_destructor_by_function ( const talloc_context * chunk_context, talloc_destructor_function function );*

If chunk_context is NULL function will return non-zero value.
Otherwise function will obtain chunk from chunk_context and delete destructor by function from it's destructors list.
Function returns zero or non-zero value if error occurred.
Complexity is complexity of free + O(number of linked destructors).

*uint8_t talloc_del_destructor_by_data ( const talloc_context * chunk_context, void * user_data );*

If chunk_context is NULL function will return non-zero value.
Otherwise function will obtain chunk from chunk_context and delete destructor by user_data from it's destructors list.
Function returns zero or non-zero value if error occurred.
Complexity is complexity of free + O(number of linked destructors).

*Example*

    uint8_t empty_destructor ( talloc_context * context, void * user_data )
    {
        return 0;
    }

    uint8_t bad_destructor ( talloc_context * context, void * user_data )
    {
        return 1;
    }

    uint8_t file_destructor ( talloc_context * context, void * user_data )
    {
        int file_descriptor = * ( ( int * ) context );
        char * filename     = user_data;
        printf ( "closing file %s\n", filename );
        close ( file_descriptor );
        return 0;
    }

    int main ()
    {
        talloc_context * root = talloc_new ( NULL );
        if ( root == NULL ) {
            return 1;
        }
        int * file_descriptor = talloc ( root, sizeof ( int ) );
        if ( file_descriptor == NULL ) {
            talloc_free ( root );
            return 2;
        }
        char * filename = talloc_strdup ( file_descriptor, "/etc/fstab" );
        * file_descriptor = open ( filename, O_RDONLY );
        if ( * file_descriptor == -1 ) {
            talloc_free ( root );
            return 3;
        }
        if (
            talloc_add_destructor ( file_descriptor, file_destructor,  filename ) != 0 ||
            talloc_add_destructor ( file_descriptor, empty_destructor, filename ) != 0 ||
            talloc_add_destructor ( file_descriptor, bad_destructor,   filename ) != 0 ||
            talloc_add_destructor ( file_descriptor, empty_destructor, NULL )     != 0
        ) {
            talloc_free ( root );
            return 4;
        }
        if (
            talloc_del_destructor             ( file_descriptor, empty_destructor, filename ) != 0 ||
            talloc_del_destructor_by_function ( file_descriptor, bad_destructor )             != 0 ||
            talloc_del_destructor_by_data     ( file_descriptor, NULL )                       != 0
        ) {
            talloc_free ( root );
            return 5;
        }
        if ( talloc_free ( root ) != 0 ) {
            return 6;
        }
        return 0;
    }



reference/main.h
----------------
*talloc_context * talloc_add_reference_with_data ( const talloc_context * child_context, const talloc_context * parent_context, size_t length );*

Function works the same as "talloc_add_reference".
Function returns pointer to memory (with length size) or NULL if error occurred.

*talloc_context * talloc_add_reference_with_zero_data ( const talloc_context * child_context, const talloc_context * parent_context, size_t length );*

Function works the same as "talloc_add_reference_with_data".
It will use calloc instead of malloc to allocate new reference.

*talloc_context * talloc_add_reference ( const talloc_context * child_context, const talloc_context * parent_context );*

If child_context is NULL or child_context equals parent_context function will return non-zero value.
Function will obtain child chunk from child_context, parent chunk from parent_context.
If child chunk's parent is parent chunk function will return non-zero value.
Otherwise function will create reference to child_context and attach it to parent chunk.
Function returns pointer to memory (with zero size) or NULL if error occurred.
This memory should not be used for storing information.

*uint8_t talloc_clear_references ( const talloc_context * chunk_context );*

If chunk_context is NULL function will return non-zero value.
Otherwise function will obtain chunk from chunk_context and delete all it's references.
Function returns zero or non-zero value if error occurred.

*Example*

    static inline
    void random_sleep ()
    {
        uint miliseconds = ( ( double ) rand() ) / RAND_MAX * 300 + 100; // from 100 to 300 miliseconds
        usleep ( miliseconds * 1000 );
    }

    void * thread_1 ( void * data )
    {
        char * common           = data;
        void * common_reference = talloc_add_reference ( common, NULL );
        if ( common_reference == NULL ) {
            return ( void * ) 1;
        }
        random_sleep();
        talloc_free ( common_reference ); // may free common
        return ( void * ) 0;
    }

    void * thread_2 ( void * data )
    {
        char * common           = data;
        void * common_reference = talloc_add_reference ( common, NULL );
        if ( common_reference == NULL ) {
            return ( void * ) 1;
        }
        random_sleep();
        talloc_free ( common_reference ); // may free common
        return ( void * ) 0;
    }

    int main ()
    {
        talloc_context * root = talloc_new ( NULL );
        if ( root == NULL ) {
            return 1;
        }
        char * common = talloc_strdup (
            NULL,
            "This is big data, that you dont want to duplicate."
            "Different code needs it."
            "You want it to be fried automaticaly when all code have finished it's processing."
        );
        if ( common == NULL ) {
            talloc_free ( root );
            return 2;
        }

        time_t seed = time ( NULL );
        srand ( seed );

        pthread_t thread_1_id, thread_2_id;
        if (
            pthread_create ( &thread_1_id, NULL, thread_1, common ) != 0 ||
            pthread_create ( &thread_2_id, NULL, thread_2, common ) != 0
        ) {
            talloc_free ( root );
            return 2;
        }

        void * result;
        if (
            pthread_join ( thread_1_id, &result ) != 0 || ( uint8_t ) result != 0 ||
            pthread_join ( thread_2_id, &result ) != 0 || ( uint8_t ) result != 0
        ) {
            talloc_free ( root );
            return 3;
        }

        if ( talloc_free ( root ) != 0 ) {
            return 4;
        }
        return 0;
    }



utils/dynarr.h
--------------
*talloc_dynarr * talloc_dynarr_new ( const talloc_context * ctx, size_t capacity );*

Function creates new dynamic array with capacity and attaches it to ctx.
Function returns pointer to talloc_dynarr or NULL if error occurred.

*uint8_t talloc_dynarr_insert_before ( talloc_dynarr * arr, size_t index, void * data );*

Function inserts data before index position to arr.
Function returns zero or non-zero value if error occurred.

*uint8_t talloc_dynarr_insert_after ( talloc_dynarr * arr, size_t index, void * data );*

Function inserts data after index position to arr.
Function returns zero or non-zero value if error occurred.

*uint8_t talloc_dynarr_grow_and_set ( talloc_dynarr * arr, size_t index, void * data );*

Function grows arr to index + 1 position and sets data to index.
Function returns zero or non-zero value if error occurred.

*void talloc_dynarr_set ( talloc_dynarr * arr, size_t index, void * data );*

Function sets data to index in arr.

*void * talloc_dynarr_get ( const talloc_dynarr * arr, size_t index );*

Function returns data from index in arr.

*size_t talloc_dynarr_get_length ( const talloc_dynarr * arr );*

Function returns length from arr.

*uint8_t talloc_dynarr_push ( talloc_dynarr * arr, void * data );*

Function pushes data to arr.
Function returns zero or non-zero value if error occurred.

*uint8_t talloc_dynarr_pop ( talloc_dynarr * arr );*

Function deletes first data from arr.
Function returns zero or non-zero value if error occurred.

*uint8_t talloc_dynarr_delete ( talloc_dynarr * arr, size_t index );*

Function deletes data from index in arr.
Function returns zero or non-zero value if error occurred.



utils/buffer.h
--------------
*talloc_buffer * talloc_buffer_new ( const talloc_context * ctx );*

Function creates new buffer and attaches it to ctx.
Function returns pointer to talloc_buffer or NULL if error occurred.

*void talloc_buffer_written ( talloc_buffer * buffer, size_t length );*

Function adds length written to buffer.

*uint8_t talloc_buffer_readed ( talloc_buffer * buffer, size_t length );*

Function deletes length readed from buffer.
Function returns zero or non-zero value if error occurred.

*uint8_t * talloc_buffer_get_read_point ( const talloc_buffer * buffer );*

Function returns read point of buffer.

*uint8_t * talloc_buffer_get_write_point ( const talloc_buffer * buffer );*

Function returns write point of buffer.

*size_t talloc_buffer_get_length ( const talloc_buffer * buffer );*

Function returns length of buffer.

*uint8_t talloc_buffer_prepare ( talloc_buffer * buffer, size_t length );*

Function prepairs buffer for writing length bytes.
Function returns zero or non-zero value if error occurred.

*uint8_t talloc_buffer_trim ( talloc_buffer * buffer );*

Function trims readed data and empty tail from buffer.
Function returns zero or non-zero value if error occurred.



SEE ALSO
--------
*talloc*(3)



AUTHORS
-------
  Andrew Aladjev <aladjev.andrew@gmail.com>